we called the infrastructure "Flyton" , 
Flyton is a methodology of writing code for web projects , 
the Rules:
- using apahce2 on linux ubuntu on EC2 on AWS
- using cloudFront to map a domain with SSL to the ptoject , ex: https://www.myproject.com will point to the ip of the EC2 server
- using mysql database
- apache2 will have a cgi script that will run the python code on server side and generate the HTML output (like php)
- The Flyton core of code will be openSource , it's include a long list (follow up)
- Use AWS cloud9 as the IDE on the dev server , prod server will be accessed only from the "dev" 
- Flyton core of utility are:
-- the cgi script
-- mysql access platform with few functions , write and read from the database
-- some utility in python to generate nice buttons and HTML elements
-- all session management , from the login to the clearing of expired session
-- manage the jump from one page of html to the next page using functions in python
-- manage calling to the server via api , a set of JS code for client and python code for the server which will make it easy to jump from the client directly to the server python code and exchage Objects
-a directory structure , for
-- client
-- server
-- static pages HTMR/CSS/JS/assets 
-Mysql 
-- all acces via one utiity , sql.py with read/write/delete ready made functions
--- read find_in_sql()
--- write/update insert_to_sql()
--All tables in the database will have the same structure
---the unique id "id" - most of the time will be integer , autoIncrement , start with 4 digit or 5 digit for convineint , some talbes will strat with 300 , some with 4000 - so id's in the system will be easy to recognize , amount of digits will be design for the amount of maximum records we intesipate
---field "name" - text
---field "is_active" = 1 if active (default) 0 if not - we will not delete records , we will mark the "is_active"=0 , is_active is integer
---field "created_at" - date of creatation (automatically)
---field "updated_at" - date of modify (automatically)
---field "data" - json format - will hold dynamic field of a record 
---other field as needed - But only if all records need it.
--all condition in Database is 0 or 1 , 0 is false , 1 is true
--file contain the create command of SQL : tables.sql - with documentations and exaple of records for each table 
--in this file , the DROP connad will also be documented so you wuill be able to delete a table
--in this file , short example (3 lines top) of each table , so programmers will be learn from example of structure of tales
--mysql shell in linux - we use the shell only - so programmers will be use to use SQL commands - not a web platform 
-writing code
--Simple
---if you have 4 way of writing - do the simp[e way
---avoid "else" or "elif" - when a programmer read a code - it's more easy to read condition with no "else"
--all conditions 0-faluse 1-true -- do not use Tru of python or 'true' of javascript. 
--using an f-string as a main function to embeded a variable into the string of the HTML you generate
--do not put condition inside the f-string - use the condition before generating the HTML
--do not put JS code in python , make it a file.js with your JS code.
--the web page need to be cut into at least 3 parts , header,body,footer
--the "body" part need to be dynamic based on an "rpage" - variable which should redirect the python code to rpage.py ( if rpage="about" the page need to be about.py )
--the directory scturcure
---/client/admin
---/client/weba
---/client/pages
---/client/pages/lib
---/client/pages/files
---/client/pages/im
---/server
---/server/cgi-bin
---/server/apis
---/server/apis/api
---/server/apis/tools
---/server/apis/tools/cron
-- The tools on the server side will be linked to the clien side 
-- server side "tools" 
--- will hold all the open source utility
--- all database access will have a db_table.py name so the table name is "table" , ex: if there is a "prod" table for products the file will be called db_prod.py
--- naming , if there is a user , it's id is user_id , if there is a product with "prod" table , it's id is "prod_id" , the id's are integers
--- use short variables naming
--- use the same table name in all other variante of the naming , 
---- example : product , the id - prod_id , the object is prod["name"]="product name" prod["is_active"]=1 ....
---- table that extend main table will have it's name as prefix , ex: product data , main table "prod" , data of product table name "prod_data" , prod_dat table will include the key "prod_id" which will point the the "prod" table
--Functions naming:
---only lower case
---first function on a .py file will have the same name of the file : dashboard.py will have "def dashbord(data):" function name.
--Do not install any packages !!! 
--if you must install - it's need to be very very low and only of you have no other chices
--each file of page will have a data object : def contact(data):  the data wil have the session saved data and the session id :   ses=data["ses"]
-sessions
-- sessions will be managed on "ses"table on the SQL
-- do not use cookies or localStorage , the session will save the session id on the LocalSession storage of the browser
-- use our login.html example to connect user to the system , use our MFA example as well if needed 
-- save to a session data if you need it in the next pages , the session data will be save in the "ses" table , and will be ready for you at each page in the data["s"] object 
-- use our add2ses function for that 
-- "ses" table is the only table which the id is not integer, it's a token string key 
-archive 
--use our archive engine , so tables that old can be cleaned up , use it for sessions and logs data 
-each records on our mysql have a json format field name "data" , use it for dynamics variable to save , use our get_data() functions and save_to_data functions in the core openSource utility
-use our core find_in_sql() function to scan the database and select a records , it's support a lot of options , with smart join ability.
-Do Not use SQL command at all
-temporary short term variable inside a loop , is as short as posible , but related to the variable you user , example, loop of table of users , use the key as "u" 
-use only lower case variables , or use _ but keep in short as posible 
-Use class rarely - the span life of a web page while it bbeeing generated is a shrt one - no need for classes 
-Write web pages on the fly - you need to know HTML / CSS and Javascrit as an expert 
-Avoide using JS if you don't need , generate all you can in the Python Server side 
-Writing Javascript
--use JS for client side interactiv
--do not search you element using class name , add id to each element you need to access 
--define events inline in the element onclick=xxx() do not use afterload event locking , programmesr need to find the events easylly inline on the element 
-api's 
-- use our utility to access server side 
-- it's secure and make the JS code on the client very simple 
-- the tools let you exchange objects , fro JS to python and back 
-- api's are used for html pages to be dynamics 
- table "gen" 
-- will contain the general constant of the system 
-- even small tables that not changed in time 
- table "users"
- table "logs" 
- table "ses" - active sessions 
- while writing code in python dont import the internal function one by one , use * fro them all , example 
not good:
from sql import find_in_sql, insert_to_sql
good:
from tools.sql import *


More detaied instruction:
this is the url : 
https://www.ra.yaw.red/cgi-bin/p?app=start&r=309012&ses=2a866fc021714b6ab459bb3d03421&rpage=dashboard

explain: 
The domain will be change from project to project , (www.ra.yaw.red)
The (https) achived by installing the CloudFront on AWS and link it to the EC2 server on , the certificate is also from AWS , the DNS is AWS route53 , so out server can work locally with http on port 80
The (/cgi-bin/p) is the main bash script : the bash script is here: (only two lines)

#!/usr/bin/python3 
import p4web

the p4web.py file will be explain later.
The (app=start) - is a fix and save for future 
The r=... is for future
The (ses=...) is the current user session code , each browser and each tab have it's own session code , will be alocated for each user complete the login part , you will see the ses= on ALL pages on the browser
The (rpage=...) is the current page running , the source code for rpage=dashboard is on dashboard.py file 

Next is how the core flyton works:
there is /cgi-bin/p which call to p4web.py which call to /client/app/start.py , this srouce code will run 3 pythons 1.header.py 2.body.pt 3.footer.py the body will call to "dashboard.py" ig the rpage=dashboard
This description is the core of the source flow
The source og the p4web.py is here: https://github.com/yaweli/flyton/blob/main/server/cgi-bin/p4web.py , you need to read it to understand how the core flyton call the other python code of the page

How static pages works:
You can also run an html static pages , exmaple /pages/login/ will load the index.html with no use of flyton core 


Using api from client to server: 
if we want to communicate from the client to the server (exmaple for single page application) we have a core JS code for client side and python code for server side to cummunicate and exchange data , the client will send a method and an Object with data ,
  the python side (server) will run python code abd return answer in the form of JS object , 
  it will also can return error if the process is wrong , the error handling is in the core of the Flyton.
the call_Server js code is here : https://github.com/yaweli/flyton/blob/main/client/lib/kicdev.server.js you need to include it on the client page: <script src="../../lib/kicdev.server.js"></script>
When you need to call to the server , on the client , do this:
  var responseData = await call_server(meth,inp) ; 
 
  the meth is ="api_checklogin"  // each api should have different method name , and start with api_ 
  the inp is = {"user":"foo","email":"foo@foo.com"}  which is an JS object , the python side (/server/api/apis/api_checklogin.py) will recieve this as a Python object

So the python side will be able to react to this like this: (source code is: api_checklogin.py)

def api_checklogin(data):
    i = data["post"]["input"]
    u = i["user"]
    e = i["email"]
	if user_exist(u, e):
	    api_ok()
	else:
		api_err("no such user")

The JS side will chack the answer:
	if(responseData["server"]["allow"]) 
	{
		alert("login ok")
		...
	}


Also this is just an example, this is how ALL api works , meth= for action and inp= for data for this action.
The "allow" answer can hold more data from the server , like this: server side api_ok({"more_data":3}) and the client see it in responseData["server"]["more_data"]

To be able to create new Flyton code , you will need to read the code on https://github.com/yaweli/flyton/tree/main and the examples 